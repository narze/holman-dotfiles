# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
  source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

# Customize to your needs...

export PATH="$HOME/.bin:$PATH"

export PATH="$PATH:/usr/local/lib/node_modules"
source $(brew --prefix nvm)/nvm.sh
nvm use default

export PATH="$HOME/.rbenv/bin:$PATH"
eval "$(rbenv init - zsh --no-rehash)"

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

# Customize to your needs...
# export PATH=/usr/local/heroku/bin:./bin:/Users/narze/.rbenv/shims:/usr/local/bin:/usr/local/sbin:/Users/narze/.sfs:/Users/narze/Dropbox/dotfiles/bin:/usr/bin:/bin:/usr/sbin:/sbin:s/narze/.sfs:/opt/boxen/homebrew/bin

# MacPorts
# export PATH=/opt/local/bin:/opt/local/sbin:$PATH

# python
# export PATH=$PATH:~/Library/Python/2.7/bin/

# Android path
# export PATH=$PATH:/Applications/adt-bundle-mac/sdk/platform-tools:/Applications/adt-bundle-mac/sdk/tools

# npm path
# export PATH=/usr/local/share/npm/bin:$PATH

# gem path
# export PATH=$PATH:$GEM_HOME

# postgresapp path
# export PATH=/Applications/Postgres.app/Contents/MacOS/bin:$PATH

# composer path
export PATH=~/.composer/vendor/bin:$PATH

#### dotfile's .zshrc ####

# shortcut to this dotfiles path is $ZSH
export ZSH=$HOME/.dotfiles

# your project folder that we can `c [tab]` to
export PROJECTS=~/Projects

# z
. `brew --prefix`/etc/profile.d/z.sh

# source every .zsh file in this rep
for config_file ($ZSH/**/*.zsh) do 
  [[ $config_file =~ (zsh/prompt.zsh|window.zsh)$ ]] && continue
  [[ "$(basename $config_file)" == "completion.zsh" ]] && continue
  source $config_file
done

unset config_file

# Stash your environment variables in ~/.localrc. This means they'll stay out
# of your main dotfiles repository (which may be public, like this one), but
# you'll have access to them in your scripts.
if [[ -a ~/.localrc ]]
then
  source ~/.localrc
fi

# load every completion after autocomplete loads
for config_file ($ZSH/**/completion.zsh) source $config_file
PATH=$PATH:$HOME/.rvm/bin # Add RVM to PATH for scripting

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

# initialize tmux
# [[ $TERM != screen* ]] && tmux kill-session -t Default ; tmuxinator start Default

# set LANG to unicode
LANG="en_US.UTF-8"
LC_COLLATE="en_US.UTF-8"
LC_CTYPE="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_ALL="en_US.UTF-8"

# boxen environment
# [ -f /opt/boxen/env.sh ] && . /opt/boxen/env.sh

# rbenv shims & autocomplete
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

rbenv shell --unset

# powerline for zsh
# . ~/Library/Python/2.7/lib/python/site-packages/powerline/bindings/zsh/powerline.zsh

#### Revert $ZSH to prevent errors ####
# Path to your oh-my-zsh configuration.
# export ZSH=$HOME/.oh-my-zsh

# all of our zsh files
typeset -U config_files
config_files=($ZSH/**/*.zsh)

# load the path files
#for file in ${(M)config_files:#*/path.zsh}
# do
##  source $file
##done

# load everything but the path and completion files
# for file in ${${config_files:#*/path.zsh}:#*/completion.zsh}
# do
#   source $file
# done

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit

autoload -Uz promptinit
promptinit
prompt skwp

# load every completion after autocomplete loads
# for file in ${(M)config_files:#*/completion.zsh}
# do
#  source $file
# done

unset config_files

setopt auto_cd

unsetopt correct
unsetopt correct_all

# init fasd https://github.com/clvv/fasd
if which fasd > /dev/null; then eval "$(fasd --init auto)"; fi

# Bundler exec
[ -f ~/.bundler-exec.sh ] && source ~/.bundler-exec.sh

# Config for zsh-notify
# export SYS_NOTIFIER=$(which terminal-notifier)
export SYS_NOTIFIER=/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier
export NOTIFY_COMMAND_COMPLETE_TIMEOUT=15

# Cursor indicator on vi-mode
function zle-keymap-select zle-line-init
{
    # change cursor shape in iTerm2
    case $KEYMAP in
        vicmd)      print -n -- "\E]50;CursorShape=0\C-G";;  # block cursor
        viins|main) print -n -- "\E]50;CursorShape=1\C-G";;  # line cursor
    esac

    # zle reset-prompt
    zle -R
}

function zle-line-finish
{
    print -n -- "\E]50;CursorShape=0\C-G"  # block cursor
}

zle -N zle-line-init
zle -N zle-line-finish
zle -N zle-keymap-select

# Change soft limit fro 256 to 1000
ulimit -n 1000